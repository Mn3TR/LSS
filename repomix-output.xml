This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
biome.json
LICENSE
package.json
README.md
src/BootstrapWrapper/BootstrapWrapper.ts
src/Fronter/Fronter.ts
src/Runner/Runner.ts
src/Runner/RunnerLogHandler.ts
src/RunnerWrapper/RunnerWrapper.ts
src/RunnerWrapper/TaskParamHelper.ts
src/type/appenv.type.ts
src/type/env.d.ts
src/type/queue.type.ts
src/type/task.type.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
bin
dist
node_modules
temp
config.json
package
</file>

<file path="biome.json">
{
    "$schema": "https://biomejs.dev/schemas/2.3.10/schema.json",
    "linter": {
        "enabled": true,
        "rules": {
            "recommended": true,
            "style": {
                "useImportType": "error",
                "noNonNullAssertion": "warn"
            },
            "correctness": {
                "noUnusedVariables": "warn"
            }
        }
    },
    "formatter": {
        "enabled": true,
        "indentStyle": "space",
        "indentWidth": 4,
        "lineWidth": 80
    },
    "javascript": {
        "formatter": {
            "quoteStyle": "double",
            "trailingCommas": "all"
        }
    }
}
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 MN3TR

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="src/Fronter/Fronter.ts">
import * as fs from "node:fs";
import * as path from "node:path";
import BootstrapWrapper from "../BootstrapWrapper/BootstrapWrapper";
import RunnerWrapper from "../RunnerWrapper/RunnerWrapper";
import { QueueSchema, queue } from "../type/queue.type";
import { TaskSchema, task } from "../type/task.type";

//TODO
class LSSHttpServer {}

/**
 * 解析命令行参数并确定任务执行模式。
 * 该函数根据BootstrapWrapper提供的参数识别指令类型(单任务或队列),并将相对路径解析为绝对路径.
 * @example
 * // 命令行输入: lss.exe rt "./task.json"
 * // 返回: { type: "task", filePath: "C:/absolute/path/task.json" }
 * @returns {Object} 返回包含模式类型和解析后文件路径的对象
 * @returns {"task" | "queue"} type - 执行模式：'rt' (task) 或 'rq' (queue)
 * @returns {string} filePath - 任务配置文件的绝对路径
 * @throws {Error} 如果参数无法识别，将打印错误日志并调用 `process.exit(0)` 终止进程
 */
function parse(): string {
    const [, , cmd, file] = BootstrapWrapper.argv;

    if (BootstrapWrapper.argc === 4 && cmd === "run" && file) {
        return path.resolve(BootstrapWrapper.env.selfPath, file);
    }

    console.error(`Unknown arg:${cmd}`);
    process.exit(0);
}

/**
 * 调度中心类，负责初始化执行环境并分发任务。
 */
class Fronter {
    /** 绑定的 HTTP 服务类 */
    static LSSHttpServer = LSSHttpServer;

    /**
     * 应用程序入口方法。
     * * 该方法执行以下流程：
     * 1. 初始化引导环境 (BootstrapWrapper)。
     * 2. 解析命令行参数获取操作模式及文件路径。
     * 3. 校验配置文件存在性。
     * 4. 读取并解析 JSON 配置，根据 `type` 字段初始化对应的运行器 (RunnerWrapper)。
     * * @returns {void}
     * @throws {Error} 如果配置文件格式非法或读取失败，将抛出异常；若文件不存在则退出进程。
     */
    main(): void {
        BootstrapWrapper.init();
        const filePath = parse();

        const rawConfig = JSON.parse(fs.readFileSync(filePath, "utf8"));

        if (rawConfig.type === "task") {
            const validated = TaskSchema.parse(rawConfig); // 校验任务
            RunnerWrapper.init(new task(validated));
        } else if (rawConfig.type === "queue") {
            const validated = QueueSchema.parse(rawConfig); // 校验队列
            RunnerWrapper.init(new queue(validated));
        }
    }
}

new Fronter().main();
</file>

<file path="src/RunnerWrapper/RunnerWrapper.ts">
import _Runner from "../Runner/Runner";
import { queue } from "../type/queue.type";
import { task } from "../type/task.type";
import _ParamHelper from "./TaskParamHelper";

class RunnerWrapper {
    /**
     * 联动：不再接收匿名的 object，而是明确的类实例
     */
    async init(obj: task | queue) {
        if (obj instanceof task) {
            await this.newTask(obj);
        } else if (obj instanceof queue) {
            // 联动：循环执行队列中的任务实例
            for (const t of obj.tasks) {
                await this.newTask(t);
            }
        }
    }

    private async newTask(t: task) {
        // 联动：利用 Zod 确保 taskParamConfig 在 isNeedParam 为 true 时存在
        if (t.config.isNeedParam && t.config.taskParamConfig) {
            const ParamHelper = new _ParamHelper(t.config.taskParamConfig);
            ParamHelper.backup();
            ParamHelper.write();
        }

        const runner = new _Runner(t);
        try {
            await runner.run();
        } finally {
            if (t.config.isNeedParam && t.config.taskParamConfig) {
                const ParamHelper = new _ParamHelper(t.config.taskParamConfig);
                ParamHelper.recovery();
            }
        }
    }
}

export default new RunnerWrapper();
</file>

<file path="src/RunnerWrapper/TaskParamHelper.ts">
import * as crypto from "node:crypto";
import * as fs from "node:fs";
import * as path from "node:path";
import _ from "lodash";
import BootstrapWrapper from "../BootstrapWrapper/BootstrapWrapper";
import type { ITaskParamConfig } from "../type/task.type";

/**
 * 任务参数辅助类，负责管理配置文件的备份、参数合并与状态恢复。
 * * 该工具通常用于在执行任务前，将动态参数 (Param) 注入到静态配置文件 (Config) 中，
 * 并在任务结束后通过备份文件恢复原始配置，确保配置文件的纯净性。
 */
class TaskParamHelper {
    /** 目标配置文件的绝对或相对路径 */
    private configFilePath: string;
    /** 包含待注入参数的文件路径 */
    private paramFilePath: string;
    /** 实例私有的备份文件名 */
    private backupFileName: string;

    /**
     * @param config 包含配置文件和参数文件路径的配置对象
     */
    constructor(config: ITaskParamConfig) {
        this.configFilePath = path.resolve(
            BootstrapWrapper.env.selfPath,
            config.configFilePath,
        );
        this.paramFilePath = path.resolve(
            BootstrapWrapper.env.selfPath,
            config.paramFilePath,
        );
        // 为每个 helper 实例生成唯一的备份标识
        const hash = crypto.randomBytes(4).toString("hex");
        this.backupFileName = `./temp/taskconfig_${Date.now()}_${hash}.bak`;
    }

    /**
     * 备份原始配置文件。
     * 将当前的配置文件复制到临时目录 (`./temp/taskconfig.bak`)。
     * @throws {Error} 若文件不存在或目录无写入权限将抛出异常。
     */
    backup(): void {
        fs.copyFileSync(this.configFilePath, this.backupFileName);
    }

    /**
     * 写入参数逻辑。
     * 读取参数文件并利用 `lodash.merge` 将其深度合并到配置文件中。
     * 注意：此操作会改变配置文件的内存对象，通常后续需配合写入磁盘操作（当前代码仅执行了内存合并）。
     * @returns {void}
     */
    write(): void {
        const config = JSON.parse(fs.readFileSync(this.configFilePath, "utf8"));
        const param = JSON.parse(fs.readFileSync(this.paramFilePath, "utf8"));
        // 深度合并参数到配置对象
        _.merge(config, param);
        fs.writeFileSync(this.configFilePath, JSON.stringify(config));
    }

    /**
     * 恢复配置文件。
     * 从临时备份文件中还原配置文件，并覆盖当前已修改的文件。
     */
    recovery(): void {
        try {
            if (fs.existsSync(this.backupFileName)) {
                fs.copyFileSync(this.backupFileName, this.configFilePath);
                fs.unlinkSync(this.backupFileName);
            }
        } catch (e) {
            console.error(`恢复失败: ${e}`);
        }
    }
}
export default TaskParamHelper;
</file>

<file path="src/type/appenv.type.ts">
interface appEnv {
    isPkg: boolean;
    selfPath: string;
}

export type { appEnv };
</file>

<file path="src/type/env.d.ts">
declare namespace NodeJS {
    interface Process {
        pkg?: {
            entrypoint: string;
            defaultEntrypoint: string;
            mountpoint: string;
        };
    }
}
</file>

<file path="src/type/queue.type.ts">
import { z } from "zod";
import { TaskSchema, task } from "./task.type";

// 定义队列 Schema
export const QueueSchema = z.object({
    type: z.literal("queue"),
    tasks: z.array(TaskSchema), // 嵌套校验每一个任务
});

export type IQueue = z.infer<typeof QueueSchema>;

export class queue {
    public readonly tasks: task[];

    constructor(data: IQueue) {
        // 将校验后的原始数据数组转换为 task 类实例数组
        this.tasks = data.tasks.map((t) => new task(t));
    }
}
</file>

<file path="tsconfig.json">
{
    "compilerOptions": {
        /* 1. 适配 pkg 的关键配置 */
        "target": "es2019", // pkg 对太新的语法支持有限，建议设为 ES2020 或更低
        "module": "CommonJS", // pkg 对 CJS 支持最稳，如果是 ESM 需要额外配置
        "outDir": "./dist", // 必须指定输出目录，方便 pkg 读取
        "rootDir": "./src", // 锁定源码根目录
        "lib": [
            "ES2019"
        ],
        "esModuleInterop": true, // 方便导入 CommonJS 编写的旧包
        "resolveJsonModule": true, // 允许导入 json，pkg 经常需要读取 package.json
        /* 3. 严格性与质量 */
        "strict": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true,
        "sourceMap": false, // 打包成二进制时，sourceMap 通常没用且增加体积
        "removeComments": true // 减小体积
    },
    "include": [
        "src/**/*"
    ],
    "exclude": [
        "node_modules",
        "dist",
        "bin"
    ]
}
</file>

<file path="package.json">
{
  "name": "lss",
  "version": "1.0.0",
  "description": "旨在解析以json文件描述的任务流程,并通过更改应用配置文件实现自动化的命令行工具",
  "license": "MIT",
  "author": "",
  "type": "commonjs",
  "main": "src/Fronter/Fronter.ts",
  "bin": "dist/bundle.js",
  "scripts": {
    "lint": "npx @biomejs/biome check --write ./src",
    "check": "tsc --noEmit",
    "bundle": "esbuild src/Fronter/Fronter.ts --bundle --platform=node --target=node18 --outfile=dist/bundle.js",
    "build": "npm run lint && npm run check && npm run bundle ",
    "pkg": "npm run build && pkg . --out-path ./bin",
    "watch-build": "nodemon --watch src --ext ts --exec \"npm run build\""
  },
  "pkg": {
    "targets": [
      "node18-win-x64"
    ],
    "outputPath": "bin"
  },
  "dependencies": {
    "@types/lodash": "^4.17.21",
    "@types/node": "^25.0.3",
    "lodash": "^4.17.21",
    "node-watch": "^0.7.4",
    "zod": "^4.2.1"
  },
  "devDependencies": {
    "@biomejs/biome": "2.3.10",
    "esbuild": "^0.27.2",
    "nodemon": "^3.1.11"
  }
}
</file>

<file path="README.md">
# LSS (Log Script Scheduler)

LSS 是一个通过解析以json文件描述的任务流程(task/queue.json),并通过更改应用配置文件,监听应用日志实现自动化的命令行工具

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)

## 核心特性

- **双模式调度**：支持单个任务 (`task`) 执行或多个任务组成的队列 (`queue`) 顺序执行。
- **动态参数注入**：在任务启动前自动将参数文件合并至目标配置文件，并在执行结束后自动从备份中恢复原始配置，确保配置文件的纯净性。
- **实时日志监听**：内置日志处理器，支持通过文件名匹配、关键字搜索或获取最新文件来实时追踪子进程输出。
- **安全保障机制**：提供任务超时强制终止逻辑，并能自动清理子进程以防止孤儿进程产生。

## 目录结构

```plaintext
src/
├── BootstrapWrapper/    # 环境检测、临时目录准备及全局配置加载
├── Fronter/             # 命令行入口，负责解析参数与模式分发
├── Runner/              # 核心执行器与日志轮询处理器
├── RunnerWrapper/       # 业务逻辑封装，执行参数备份与状态恢复
├── type/                # 基于 Zod 的强类型校验与定义
└── tsconfig.json        # 针对 CJS 和 pkg 环境优化的编译配置
```

## 快速开始

1.下载[releases](https://github.com/Mn3TR/LSS/releases)已打包好的二进制文件

2.运行任务

执行指令格式如下：

```bash
# 运行单个任务或队列
lss.exe run ./your_config.json
```

## 开发与调试

如果你想对 LSS 进行二次开发或在本地调试代码，可以参考以下说明：

1.安装依赖

```bash
npm install
```

2.启动监听模式

项目配置了监听模式,可以在代码修改后自动编译

```bash
npm run watch-build
```

3.环境说明

* 配置加载: `BootstrapWrapper` 会根据当前运行环境（源码或 `pkg` 二进制）自动定位基础路径。可直接在bundle.js文件同目录放置task/queue.json并使用相对路径,
* 临时文件: 运行时产生的备份文件（`.bak`）存放在 `./temp` 目录。该目录会被自动创建并已加入 `.gitignore`。

5.类型校验 (Zod)

所有输入配置均通过 `Zod` 进行严格校验。如果需要扩展配置项，请修改 `src/type/` 下的 Schema 定义，这能确保在任务运行前捕获格式错误。

## 配置示例

单个任务配置文件 (`task.json`)

```json
{
  "type": "task",
  "executableFilePath": "node script.js",
  "isNeedParam": true,
  "taskParamConfig": {
    "configFilePath": "settings.json",
    "paramFilePath": "input.json"
  },
  "isNeedLog": true,
  "taskLogConfig": {
    "logFileSearchMethod": "latest",
    "logFileFolderPath": "./logs",
    "successLog": "Process Completed",
    "failedLog": "Fatal Error"
  },
  "timeout": 300
}
```

Queue 配置文件示例 (`queue.json`)

```json
{
  "type": "queue",
  "tasks": [
    {
      "type": "task",
      "executableFilePath": "python process_data.py",
      "isNeedParam": true,
      "taskParamConfig": {
        "configFilePath": "config.json",
        "paramFilePath": "input_params.json"
      },
      "isNeedLog": false,
      "timeout": 30
    },
    {
      "type": "task",
      "executableFilePath": "node report_gen.js",
      "isNeedParam": false,
      "isNeedLog": true,
      "taskLogConfig": {
        "logFileSearchMethod": "latest",
        "logFileFolderPath": "./logs",
        "logTimeSectionStart": 0,
        "logTimeSectionEnd": 10,
        "logTimeFormat": "HH:mm:ss",
        "successLog": "Success",
        "failedLog": "Error"
      },
      "timeout": 60
    }
  ]
}
```

最小 Task 配置文件示例 (`minimal_task.json`)
```json
{
  "type": "task",
  "executableFilePath": "node script.js",
  "isNeedParam": false,
  "isNeedLog": false,
}
```

## 技术栈

* **Runtime**: Node.js (Target: Node18+)
* **Language**: TypeScript
* **Data Validation**: [Zod](https://zod.dev/)
* **Utilities**: [Lodash](https://lodash.com/)
* **Tooling**: [Biome](https://biomejs.dev/), [esbuild](https://esbuild.github.io/), [pkg](https://github.com/vercel/pkg)

本项目采用 [MIT License](https://www.google.com/search?q=LICENSE)。
</file>

<file path="src/BootstrapWrapper/BootstrapWrapper.ts">
import * as fs from "node:fs";
import * as path from "node:path";
import type { appEnv } from "../type/appenv.type";

/**
 * 引导程序包装器，负责预处理执行环境、配置加载及基础目录准备。
 * * 该类作为程序启动的第一站，解决了以下核心问题：
 * 1. 识别并适配可执行文件（pkg）与源代码运行环境。
 * 2. 统一管理命令行参数。
 * 3. 确保必要的缓存目录（./temp）存在。
 * 4. 同步加载全局 `config.json` 配置文件。
 */
class BootstrapWrapper {
    /** 应用程序环境信息，包含运行模式及绝对路径基础 */
    public env: appEnv = { isPkg: false, selfPath: "" };

    /** 全局配置对象，从 config.json 加载 */
    public config: object = {};

    /** 命令行参数的总个数 */
    public argc: number = process.argv.length;

    /** 原始命令行参数数组 */
    public argv: string[] = process.argv;

    /**
     * 初始化执行环境。
     * * * 逻辑流程：
     * 1. **环境检测**：通过 `process.pkg` 判断是否处于打包后的二进制环境中。
     * 2. **路径修正**：如果是 pkg 环境，使用 `execPath` 获取路径，否则使用 `cwd`。
     * 3. **目录准备**：检查并按需创建 `./temp` 临时文件夹。
     * 4. **配置加载**：校验并读取 `config.json`，若文件缺失则直接中断程序。
     * * @returns {void}
     * @throws {Error} 若 `config.json` 解析失败或权限不足，可能抛出异常。
     */
    init(): void {
        // 1. 环境与路径适配
        const isPkg = typeof process.pkg !== "undefined";
        this.env = {
            isPkg,
            selfPath: isPkg ? path.dirname(process.execPath) : process.cwd(),
        };

        // 2. 确保缓存目录存在 (更紧凑的写法)
        if (!fs.existsSync("./temp")) fs.mkdirSync("./temp");

        // 3. 配置加载
        const configPath = path.join(this.env.selfPath, "config.json");
        if (!fs.existsSync(configPath)) {
            console.error("Couldn't find config.json, use default config");
            //todo 应当用更优雅的方式解决config不存在时的问题
            return;
        }

        try {
            this.config = JSON.parse(fs.readFileSync(configPath, "utf8"));
        } catch (_e) {
            console.error("Failed to parse config.json");
            process.exit(1);
        }
    }
}

export default new BootstrapWrapper();
</file>

<file path="src/Runner/Runner.ts">
import { type ChildProcess, spawn } from "node:child_process";
import type { task } from "../type/task.type";
import type _LogHandler from "./RunnerLogHandler";

class Runner {
    private LogHandler: _LogHandler | undefined;
    private child: ChildProcess | null = null;
    private timeoutTimer: NodeJS.Timeout | null = null;

    constructor(private t: task) {
        // 关键：监听主进程信号，防止主程序退出后子进程变成“孤儿”
        this.setupSignalHandlers();
    }

    private setupSignalHandlers() {
        const killChild = () => {
            if (this.child && !this.child.killed) {
                console.log(
                    `[Runner] 正在清理子进程 (PID: ${this.child.pid})...`,
                );
                this.child.kill("SIGTERM"); // 优雅退出
            }
        };

        // 监听常见的退出信号
        process.on("SIGINT", killChild); // Ctrl+C
        process.on("SIGTERM", killChild); // 终止信号
        process.on("exit", killChild); // 主进程正常或异常结束
    }

    async run(): Promise<number | null> {
        const useStdout = this.t.config.taskLogConfig?.logSource === "stdout";

        return new Promise((resolve) => {
            // 启动子进程
            this.child = spawn(this.t.config.executableFilePath, {
                shell: true,
                detached: false, // 确保子进程不脱离会话
                stdio: useStdout ? ["inherit", "pipe", "pipe"] : "inherit",
            });

            //启动日志
            if (this.LogHandler) {
                this.LogHandler.start(this.LogHandler.defaultHandler);
                if (useStdout && this.child.stdout) {
                    this.LogHandler.start(
                        this.LogHandler.defaultHandler,
                        this.child.stdout,
                    );
                }
            }

            const pid = this.child.pid;
            console.log(
                `[Runner] 任务启动 [PID: ${pid}] [路径: ${this.t.config.executableFilePath}]`,
            );

            // 超时控制逻辑
            if (this.t.config.timeout && this.t.config.timeout > 0) {
                this.timeoutTimer = setTimeout(() => {
                    if (this.child && !this.child.killed) {
                        console.error(
                            `[Runner] 任务运行超时 (${this.t.config.timeout}s)，强制终止 PID: ${pid}`,
                        );
                        this.child.kill("SIGKILL"); // 超时强制杀掉
                    }
                }, this.t.config.timeout * 1000);
            }

            this.child.on("close", (code) => {
                this.cleanup();
                console.log(`[Runner] 进程退出，退出码: ${code}`);
                resolve(code);
            });

            this.child.on("error", (err) => {
                this.cleanup();
                console.error(`[Runner] 进程错误: ${err.message}`);
                resolve(null);
            });
        });
    }

    /**
     * 清理资源：停止日志监听、清除超时计时器
     */
    private cleanup() {
        if (this.LogHandler) this.LogHandler.stop();
        if (this.timeoutTimer) {
            clearTimeout(this.timeoutTimer);
            this.timeoutTimer = null;
        }
    }
}

export default Runner;
</file>

<file path="src/type/task.type.ts">
import { z } from "zod";

// --- 定义各个部分的 Schema ---

export const TaskParamConfigSchema = z.object({
    paramFilePath: z.string(),
    configFilePath: z.string(),
});

export const TaskLogConfigSchema = z.object({
    logSource: z.enum(["file", "stdout"]).optional().default("file"),
    logFileSearchMethod: z.enum(["filename", "latest", "field"]),
    logFileFolderPath: z.string(),
    logFileName: z.string().optional(),
    logFilenameField: z.string().optional(),
    logTimeSectionStart: z.number(),
    logTimeSectionEnd: z.number(),
    logTimeFormat: z.string(),
    successLog: z.union([z.string(), z.array(z.string())]),
    failedLog: z.union([z.string(), z.array(z.string())]),
});

export const TaskSchema = z.object({
    type: z.literal("task"),
    executableFilePath: z.string(),
    isNeedParam: z.boolean(),
    taskParamConfig: TaskParamConfigSchema.optional(),
    isNeedLog: z.boolean(),
    taskLogConfig: TaskLogConfigSchema.optional(),
    timeout: z.number().optional().default(0), // 单位：秒，0 表示不限时
    trackChildProcess: z.boolean().optional().default(false),
});

// --- 导出类型别名供其他文件使用 ---

export type ITask = z.infer<typeof TaskSchema>;
// 重点：显式导出子配置类型
export type ITaskLogConfig = z.infer<typeof TaskLogConfigSchema>;
export type ITaskParamConfig = z.infer<typeof TaskParamConfigSchema>;

export class task {
    constructor(public readonly config: ITask) {
        if (config.isNeedLog && !config.taskLogConfig) {
            throw new Error("task need log, but didnt give log config");
        }
        if (config.isNeedParam && !config.taskParamConfig) {
            throw new Error("task need param, but didnt give param config");
        }
    }
}
</file>

<file path="src/Runner/RunnerLogHandler.ts">
import * as fs from "node:fs";
import path from "node:path";
import type { Readable } from "node:stream";
import watch, { type Watcher } from "node-watch";
import type { ITaskLogConfig } from "../type/task.type";

/**
 * 任务日志处理器，负责定位日志文件并实时追踪新增内容。
 */
class TaskLogHandler {
    private logSource: "file" | "stdout";
    private logFilePath: string | undefined;
    private lastSize = 0;
    /** 存储上次轮询读取到的、不完整的行末尾数据 */
    private tailBuffer: Buffer = Buffer.alloc(0);
    /** 防止异步重入锁 */
    private isProcessing = false;
    //watcher实例
    private watcher?: Watcher;

    constructor(config: ITaskLogConfig) {
        this.logSource = config.logSource;
        if (this.logSource === "file") {
            let foundPath: string | null = null;

            switch (config.logFileSearchMethod) {
                case "field":
                    foundPath = this.findFile(
                        config.logFileFolderPath,
                        "field",
                        config.logFilenameField,
                    );
                    break;
                case "filename":
                    foundPath = this.findFile(
                        config.logFileFolderPath,
                        "filename",
                        config.logFileName,
                    );
                    break;
                case "latest":
                    foundPath = this.findFile(
                        config.logFileFolderPath,
                        "latest",
                    );
                    break;
            }

            if (foundPath !== null) {
                this.logFilePath = foundPath;
            } else {
                console.error(
                    `无法通过方法 "${config.logFileSearchMethod}" 找到文件。`,
                );
                process.exit(1);
            }
        }
    }

    /**
     * 启动日志监听流程。
     */
    public async start(
        callback: (line: string) => void,
        stream?: Readable,
    ): Promise<void> {
        if (this.logSource === "file" && this.logFilePath) {
            try {
                // 初始化偏移量，跳过历史数据
                this.lastSize = fs.statSync(this.logFilePath).size;
            } catch {
                this.lastSize = 0;
            }
            //启动监听
            this.watcher = watch(this.logFilePath, (evt, _name) => {
                if (evt === "update") {
                    this.pollFile(callback);
                }
            });
        }

        if (this.logSource === "stdout" && stream) {
            stream.on("data", (chunk: Buffer) => {
                this.processNewBuffer(callback, chunk);
            });
            stream.on("data", (chunk: Buffer) => {
                const errorLine = chunk.toString().trim();
                if (errorLine) console.error(`[Stderr] ${errorLine}`);
            });
        }
    }

    /**
     * 文件改动
     */
    private async pollFile(callback: (line: string) => void) {
        if (this.isProcessing) return;
        this.isProcessing = true;

        if (this.logFilePath) {
            try {
                if (!fs.existsSync(this.logFilePath)) return;

                const { size: currentSize } = fs.statSync(this.logFilePath);

                // 处理日志翻转（如文件被清空或重建）
                if (currentSize < this.lastSize) {
                    this.lastSize = 0;
                    this.tailBuffer = Buffer.alloc(0);
                }

                if (currentSize > this.lastSize) {
                    const readLen = currentSize - this.lastSize;
                    const buffer = Buffer.alloc(readLen);

                    // 读取增量内容
                    const fd = fs.openSync(this.logFilePath, "r");
                    try {
                        fs.readSync(fd, buffer, 0, readLen, this.lastSize);
                        this.processNewBuffer(callback, buffer);
                    } finally {
                        fs.closeSync(fd);
                    }
                }
            } catch (err) {
                console.error("Read log error:", err);
            } finally {
                this.isProcessing = false;
            }
        }
    }

    public stop(): void {
        this.watcher?.close();
    }

    public defaultHandler(line: string) {
        //console.log(line);
    }

    /**
     * 内部文件搜索算法（保持不变）
     */
    private findFile(
        dir: string,
        mode: "filename" | "latest" | "field",
        query?: string,
    ): string | null {
        try {
            const files = fs.readdirSync(dir);
            if (!files.length) return null;

            let targetFile: string | undefined;
            switch (mode) {
                case "filename":
                    targetFile = files.find((f) => f === query);
                    break;
                case "field":
                    targetFile = files.find((f) => {
                        const nameWithoutExt = path.parse(f).name;
                        return query ? nameWithoutExt.includes(query) : false;
                    });
                    break;
                case "latest":
                    targetFile = files
                        .map((f) => ({
                            name: f,
                            time:
                                fs.statSync(path.join(dir, f), {
                                    throwIfNoEntry: false,
                                })?.mtimeMs || 0,
                        }))
                        .sort((a, b) => b.time - a.time)[0]?.name;
                    break;
            }
            return targetFile ? path.join(dir, targetFile) : null;
        } catch (error) {
            console.error("文件搜索失败:", error);
            return null;
        }
    }

    /**
     * 处理新增buffer内容
     */
    private processNewBuffer(callback: (ling: string) => void, buffer: Buffer) {
        // 将上次遗留的“半行”与本次读取内容合并
        const combinedBuffer = Buffer.concat([this.tailBuffer, buffer]);
        let offset = 0;

        // 查找换行符 (0x0A 为 \n)
        while (true) {
            const nlIndex = combinedBuffer.indexOf(0x0a, offset);

            if (nlIndex === -1) {
                // 没找到换行符，剩下的部分存入 tailBuffer 等待下次轮询
                this.tailBuffer = combinedBuffer.slice(offset);
                break;
            }

            // 提取完整行，并处理 \r\n (Windows 兼容)
            const line = combinedBuffer
                .toString("utf8", offset, nlIndex)
                .replace(/\r$/, "");

            if (line.trim()) {
                callback(line);
            }

            offset = nlIndex + 1;
        }
        if (this.logSource === "file" && this.logFilePath) {
            const { size: currentSize } = fs.statSync(this.logFilePath);
            this.lastSize = currentSize;
        }
    }
}

export default TaskLogHandler;
</file>

</files>
