This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: node_modules, dist, bin, .git, package-lock.json, yarn.lock
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
biome.json
config.json
package.json
src/BootstrapWrapper/BootstrapWrapper.ts
src/Fronter/Fronter.ts
src/Runner/Runner.ts
src/Runner/RunnerLogHandler.ts
src/RunnerWrapper/RunnerWrapper.ts
src/RunnerWrapper/TaskParamHelper.ts
src/type/appenv.type.ts
src/type/env.d.ts
src/type/queue.type.ts
src/type/task.type.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="biome.json">
{
    "$schema": "https://biomejs.dev/schemas/2.3.10/schema.json",
    "linter": {
        "enabled": true,
        "rules": {
            "recommended": true,
            "style": {
                "useImportType": "error",
                "noNonNullAssertion": "warn"
            },
            "correctness": {
                "noUnusedVariables": "warn"
            }
        }
    },
    "formatter": {
        "enabled": true,
        "indentStyle": "space",
        "indentWidth": 4,
        "lineWidth": 80
    },
    "javascript": {
        "formatter": {
            "quoteStyle": "double",
            "trailingCommas": "all"
        }
    }
}
</file>

<file path="config.json">
{}
</file>

<file path="package.json">
{
  "name": "lss",
  "version": "1.0.0",
  "description": "",
  "license": "MIT",
  "author": "",
  "type": "commonjs",
  "main": "src/Fronter/Fronter.ts",
  "bin": "dist/bundle.js",
  "scripts": {
    "lint": "npx @biomejs/biome check --write ./src",
    "check": "tsc --noEmit",
    "bundle": "esbuild src/Fronter/Fronter.ts --bundle --platform=node --target=node18 --outfile=dist/bundle.js",
    "build": "npm run lint && npm run check && npm run bundle ",
    "pkg": "npm run build && pkg . --out-path ./bin",
    "watch-build": "nodemon --watch src --ext ts --exec \"npm run build\""
  },
  "pkg": {
    "targets": [
      "node18-win-x64"
    ],
    "outputPath": "bin"
  },
  "dependencies": {
    "@types/lodash": "^4.17.21",
    "@types/node": "^25.0.3",
    "lodash": "^4.17.21",
    "zod": "^4.2.1"
  },
  "devDependencies": {
    "@biomejs/biome": "2.3.10",
    "esbuild": "^0.27.2",
    "nodemon": "^3.1.11"
  }
}
</file>

<file path="src/BootstrapWrapper/BootstrapWrapper.ts">
import * as fs from "node:fs";
import * as path from "node:path";
import type { appEnv } from "../type/appenv.type";

/**
 * 引导程序包装器，负责预处理执行环境、配置加载及基础目录准备。
 * * 该类作为程序启动的第一站，解决了以下核心问题：
 * 1. 识别并适配可执行文件（pkg）与源代码运行环境。
 * 2. 统一管理命令行参数。
 * 3. 确保必要的缓存目录（./temp）存在。
 * 4. 同步加载全局 `config.json` 配置文件。
 */
class BootstrapWrapper {
    /** 应用程序环境信息，包含运行模式及绝对路径基础 */
    public env: appEnv = { isPkg: false, selfPath: "" };

    /** 全局配置对象，从 config.json 加载 */
    public config: object = {};

    /** 命令行参数的总个数 */
    public argc: number = process.argv.length;

    /** 原始命令行参数数组 */
    public argv: string[] = process.argv;

    /**
     * 初始化执行环境。
     * * * 逻辑流程：
     * 1. **环境检测**：通过 `process.pkg` 判断是否处于打包后的二进制环境中。
     * 2. **路径修正**：如果是 pkg 环境，使用 `execPath` 获取路径，否则使用 `cwd`。
     * 3. **目录准备**：检查并按需创建 `./temp` 临时文件夹。
     * 4. **配置加载**：校验并读取 `config.json`，若文件缺失则直接中断程序。
     * * @returns {void}
     * @throws {Error} 若 `config.json` 解析失败或权限不足，可能抛出异常。
     */
    init(): void {
        // 1. 环境与路径适配
        const isPkg = typeof process.pkg !== "undefined";
        this.env = {
            isPkg,
            selfPath: isPkg ? path.dirname(process.execPath) : process.cwd(),
        };

        // 2. 确保缓存目录存在 (更紧凑的写法)
        if (!fs.existsSync("./temp")) fs.mkdirSync("./temp");

        // 3. 配置加载
        const configPath = path.join(this.env.selfPath, "config.json");
        if (!fs.existsSync(configPath)) {
            console.error("Couldn't find config.json");
            process.exit(1);
        }

        try {
            this.config = JSON.parse(fs.readFileSync(configPath, "utf8"));
        } catch (_e) {
            console.error("Failed to parse config.json");
            process.exit(1);
        }
    }
}

export default new BootstrapWrapper();
</file>

<file path="src/Fronter/Fronter.ts">
import * as fs from "node:fs";
import * as path from "node:path";
import BootstrapWrapper from "../BootstrapWrapper/BootstrapWrapper";
import RunnerWrapper from "../RunnerWrapper/RunnerWrapper";

//TODO
class LSSHttpServer {}

/**
 * 解析命令行参数并确定任务执行模式。
 * 该函数根据BootstrapWrapper提供的参数识别指令类型(单任务或队列),并将相对路径解析为绝对路径.
 * @example
 * // 命令行输入: lss.exe rt "./task.json"
 * // 返回: { type: "task", filePath: "C:/absolute/path/task.json" }
 * @returns {Object} 返回包含模式类型和解析后文件路径的对象
 * @returns {"task" | "queue"} type - 执行模式：'rt' (task) 或 'rq' (queue)
 * @returns {string} filePath - 任务配置文件的绝对路径
 * @throws {Error} 如果参数无法识别，将打印错误日志并调用 `process.exit(0)` 终止进程
 */
function parse(): { type: "task" | "queue"; filePath: string } {
    const [, , cmd, file] = BootstrapWrapper.argv;

    // 指令映射表
    const map: Record<string, "task" | "queue"> = {
        rt: "task",
        runtask: "task",
        rq: "queue",
        runqueue: "queue",
    };

    const type = map[cmd];

    if (BootstrapWrapper.argc === 4 && type && file) {
        return {
            type,
            filePath: path.resolve(BootstrapWrapper.env.selfPath, file),
        };
    }

    console.error(`Unknown arg:${cmd}`);
    process.exit(0);
}

/**
 * 调度中心类，负责初始化执行环境并分发任务。
 */
class Fronter {
    /** 绑定的 HTTP 服务类 */
    static LSSHttpServer = LSSHttpServer;

    /**
     * 应用程序入口方法。
     * * 该方法执行以下流程：
     * 1. 初始化引导环境 (BootstrapWrapper)。
     * 2. 解析命令行参数获取操作模式及文件路径。
     * 3. 校验配置文件存在性。
     * 4. 读取并解析 JSON 配置，根据 `type` 字段初始化对应的运行器 (RunnerWrapper)。
     * * @returns {void}
     * @throws {Error} 如果配置文件格式非法或读取失败，将抛出异常；若文件不存在则退出进程。
     */
    main() {
        BootstrapWrapper.init();
        const operation = parse();

        if (!fs.existsSync(operation.filePath)) {
            console.error(`Couldn't find task/queue file${operation.filePath}`);
            process.exit(1);
        }

        const parsedConfig = JSON.parse(
            fs.readFileSync(operation.filePath).toString(),
        );
        if (parsedConfig.type === "task") {
            RunnerWrapper.init("task", parsedConfig);
        }
        if (parsedConfig.type === "queue") {
            RunnerWrapper.init("queue", parsedConfig);
        }
    }
}

new Fronter().main();
</file>

<file path="src/Runner/Runner.ts">
import { spawn } from "node:child_process";
import type { task, taskLogConfig } from "../type/task.type";
import _LogHandler from "./RunnerLogHandler";

/**
 * 任务运行器类，负责执行具体的可执行文件并管理相关的日志处理器。
 * * 该类是执行层的核心，它将 `task` 定义的静态配置转化为动态的运行进程，
 * 并根据配置决定是否挂载实时日志监控。
 */
class Runner {
    /** 任务配置对象 */
    private t: task;
    /** 关联的日志处理器实例 */
    private LogHandler: _LogHandler | undefined;

    /**
     * @param t 任务定义对象，包含路径、权限及日志配置
     */
    constructor(t: task) {
        this.t = t;
        // 如果任务需要日志追踪，则根据配置实例化处理器
        if (t.isNeedLog) {
            const logConfig = t.taskLogConfig as taskLogConfig;
            this.LogHandler = new _LogHandler(logConfig);
        }
    }

    /**
     * 启动任务流程。
     * * 1. 如果开启了日志需求，优先启动日志监听。
     * 2. 调用 `spawn` 派生子进程执行目标文件。
     * * @returns {void}
     */
    async run(): Promise<number | null> {
        if (this.t.isNeedLog && this.LogHandler) {
            this.LogHandler.start(this.LogHandler.defaultHandler);
        }

        // 返回一个 Promise，手动控制 resolve 的时机
        return new Promise((resolve) => {
            const child = spawn(this.t.executableFilePath);
            // 打印 PID
            console.log(`[身份对照] 已启动进程: ${this.t.executableFilePath}`);
            console.log(`[身份对照] 进程 PID: ${child.pid}`);
            child.on("close", (code) => {
                console.log(`子进程已退出，退出码: ${code}`);
                if (this.LogHandler) this.LogHandler.stop();
                resolve(code); // 只有这里 resolve 了，外部的 await 才会继续执行
            });

            child.on("error", (err) => {
                console.error("子进程启动失败:", err);
                if (this.LogHandler) this.LogHandler.stop();
                resolve(null);
            });
        });
    }
}

export default Runner;
</file>

<file path="src/Runner/RunnerLogHandler.ts">
import * as fs from "node:fs";
import * as path from "node:path";
import * as readline from "node:readline";
import type { taskLogConfig } from "../type/task.type";

/**
 * 任务日志处理器 (高性能事件驱动版)
 * * 该类负责定位日志文件并实时追踪其内容。
 * 核心特性：
 * 1. 使用 `fs.watch` 替代轮询，显著降低 CPU 占用并提升响应速度。
 * 2. 使用 `readline` 模块处理流，确保在高频写入或长行日志下不会出现字符截断。
 * 3. 自动记录字节偏移量 (`lastSize`)，实现增量读取。
 * 4. 具备完善的资源清理机制，防止内存泄漏。
 */
class TaskLogHandler {
    /** 最终确定的日志文件绝对路径 */
    private logFilePath: string;
    /** 上次读取结束时的文件字节偏移量 */
    private lastSize = 0;
    /** 文件监听器实例 */
    private watcher: fs.FSWatcher | null = null;
    /** 当前正在读取的流实例，用于 stop 时销毁 */
    private currentStream: fs.ReadStream | null = null;

    /**
     * 初始化日志处理器。
     * 根据配置的搜索策略在指定目录下查找目标日志文件。
     * @param config 日志配置对象，包含搜索路径及模式
     * @throws {Error} 如果无法找到任何匹配的文件，将抛出异常由上层分发器处理。
     */
    constructor(config: taskLogConfig) {
        let foundPath: string | null = null;

        switch (config.logFileSearchMethod) {
            case "field":
                foundPath = this.findFile(
                    config.logFileFolderPath,
                    "field",
                    config.logFilenameField,
                );
                break;
            case "filename":
                foundPath = this.findFile(
                    config.logFileFolderPath,
                    "filename",
                    config.logFileName,
                );
                break;
            case "latest":
                foundPath = this.findFile(config.logFileFolderPath, "latest");
                break;
        }

        if (foundPath) {
            this.logFilePath = foundPath;
        } else {
            throw new Error(
                `[LogHandler] 无法通过方法 "${config.logFileSearchMethod}" 在目录 "${config.logFileFolderPath}" 找到文件。`,
            );
        }
    }

    /**
     * 启动日志实时监听。
     * * 逻辑流程：
     * 1. 记录文件当前大小作为偏移量。
     * 2. 使用 `fs.watch` 监听 'change' 事件。
     * 3. 文件增长时，利用 `fs.createReadStream` 仅读取新增部分的字节。
     * 4. 接入 `readline` 接口，按行分发日志内容。
     * * @param callback 每一行新日志产生时的回调函数
     */
    public start(callback: (line: string) => void): void {
        try {
            // 初始化偏移量，避免读取历史旧数据
            this.lastSize = fs.statSync(this.logFilePath).size;
        } catch (_e) {
            this.lastSize = 0;
        }

        // 启动系统级文件监听
        this.watcher = fs.watch(this.logFilePath, async (eventType) => {
            if (eventType === "change") {
                this.handleFileChange(callback);
            }
        });

        // 监听异常处理（如文件被意外删除）
        this.watcher.on("error", (err) => {
            console.error(`[LogHandler] Watcher 异常: ${err.message}`);
            this.stop();
        });
    }

    /**
     * 内部方法：处理文件变动后的增量读取
     * @param callback 行处理回调
     */
    private async handleFileChange(
        callback: (line: string) => void,
    ): Promise<void> {
        try {
            const stats = fs.statSync(this.logFilePath);
            const currentSize = stats.size;

            // 如果文件缩小（可能被手动清空或滚动），重置偏移量
            if (currentSize < this.lastSize) {
                this.lastSize = 0;
            }

            if (currentSize > this.lastSize) {
                const startPos = this.lastSize;
                this.lastSize = currentSize; // 立即更新偏移量，防止并发重入读取重复内容

                this.currentStream = fs.createReadStream(this.logFilePath, {
                    start: startPos,
                    end: currentSize - 1,
                });

                const rl = readline.createInterface({
                    input: this.currentStream,
                    terminal: false,
                });

                rl.on("line", (line) => {
                    const trimmed = line.trim();
                    if (trimmed) callback(trimmed);
                });

                // 流读取完毕后的清理
                this.currentStream.on("end", () => {
                    rl.close();
                    this.currentStream = null;
                });
            }
        } catch (err) {
            console.error(`[LogHandler] 读取增量日志失败: ${err}`);
        }
    }

    /**
     * 停止监听并释放所有资源。
     * 显式关闭文件监听器并销毁当前活动的读取流。
     */
    public stop(): void {
        if (this.watcher) {
            this.watcher.close();
            this.watcher = null;
        }
        if (this.currentStream) {
            this.currentStream.destroy();
            this.currentStream = null;
        }
    }

    /**
     * 默认的行处理函数
     * @param line 捕获到的单行日志字符串
     */
    public defaultHandler(line: string): void {
        console.log(`[LOG] ${line}`);
    }

    /**
     * 内部文件搜索算法。
     * @param dir 待扫描的目录路径
     * @param mode 搜索模式：'filename' (精确匹配), 'latest' (按修改时间), 'field' (包含关键字)
     * @param query 匹配关键词或目标文件名
     * @returns {string | null} 返回找到的完整文件路径，未找到则返回 null
     */
    private findFile(
        dir: string,
        mode: "filename" | "latest" | "field",
        query?: string,
    ): string | null {
        try {
            const files = fs.readdirSync(dir);
            if (!files.length) return null;

            let targetFile: string | undefined;

            switch (mode) {
                case "filename":
                    targetFile = files.find((f) => f === query);
                    break;
                case "field":
                    targetFile = files.find((f) => {
                        const nameWithoutExt = path.parse(f).name;
                        return query ? nameWithoutExt.includes(query) : false;
                    });
                    break;
                case "latest":
                    targetFile = files
                        .map((f) => ({
                            name: f,
                            time:
                                fs.statSync(path.join(dir, f), {
                                    throwIfNoEntry: false,
                                })?.mtimeMs || 0,
                        }))
                        .sort((a, b) => b.time - a.time)[0]?.name;
                    break;
            }

            return targetFile ? path.join(dir, targetFile) : null;
        } catch (error) {
            console.error(`[LogHandler] 搜索文件失败: ${error}`);
            return null;
        }
    }
}

export default TaskLogHandler;
</file>

<file path="src/RunnerWrapper/RunnerWrapper.ts">
import _Runner from "../Runner/Runner";
import type { queue } from "../type/queue.type";
import type { task, taskParamConfig } from "../type/task.type";

import _ParamHelper from "./TaskParamHelper";

class RunnerWrapper {
    /**
     * 准备与善后工作, 为task, queue创建runner. 备份, 修改, 还原任务的config文件
     * @param type 标识传入对象类型
     * @param obj task或queue对象
     */
    init(type: "task" | "queue", obj: object) {
        //const ConfigFileHelper = new TaskConfigFileHelper()
        //const LogHandler = new TaskLogHandler()
        if (type === "task") {
            const taskObj = obj as task;
            newTask(taskObj);
        }

        if (type === "queue") {
            const queueObj = obj as queue;
            for (let i = 0; i < queueObj.tasks.length; i++) {
                newTask(queueObj.tasks[i]);
            }
        }
    }
}

async function newTask(t: task) {
    if (t.isNeedParam) {
        const paramConfig = t.taskParamConfig as taskParamConfig;
        const ParamHelper = new _ParamHelper(paramConfig);
        ParamHelper.backup();
        ParamHelper.write();
    }
    const runner = new _Runner(t);
    try {
        await runner.run();
    } finally {
        if (t.isNeedParam) {
            const paramConfig = t.taskParamConfig as taskParamConfig;
            const ParamHelper = new _ParamHelper(paramConfig);
            ParamHelper.recovery();
        }
    }
}

export default new RunnerWrapper();
</file>

<file path="src/RunnerWrapper/TaskParamHelper.ts">
import * as crypto from "node:crypto";
import * as fs from "node:fs";
import * as path from "node:path";
import _ from "lodash";
import BootstrapWrapper from "../BootstrapWrapper/BootstrapWrapper";
import type { taskParamConfig } from "../type/task.type";

/**
 * 任务参数辅助类，负责管理配置文件的备份、参数合并与状态恢复。
 * * 该工具通常用于在执行任务前，将动态参数 (Param) 注入到静态配置文件 (Config) 中，
 * 并在任务结束后通过备份文件恢复原始配置，确保配置文件的纯净性。
 */
class TaskParamHelper {
    /** 目标配置文件的绝对或相对路径 */
    private configFilePath: string;
    /** 包含待注入参数的文件路径 */
    private paramFilePath: string;
    /** 实例私有的备份文件名 */
    private backupFileName: string;

    /**
     * @param config 包含配置文件和参数文件路径的配置对象
     */
    constructor(config: taskParamConfig) {
        this.configFilePath = path.resolve(
            BootstrapWrapper.env.selfPath,
            config.configFilePath,
        );
        this.paramFilePath = path.resolve(
            BootstrapWrapper.env.selfPath,
            config.paramFilePath,
        );
        // 为每个 helper 实例生成唯一的备份标识
        const hash = crypto.randomBytes(4).toString("hex");
        this.backupFileName = `./temp/taskconfig_${Date.now()}_${hash}.bak`;
    }

    /**
     * 备份原始配置文件。
     * 将当前的配置文件复制到临时目录 (`./temp/taskconfig.bak`)。
     * @throws {Error} 若文件不存在或目录无写入权限将抛出异常。
     */
    backup(): void {
        fs.copyFileSync(this.configFilePath, this.backupFileName);
    }

    /**
     * 写入参数逻辑。
     * 读取参数文件并利用 `lodash.merge` 将其深度合并到配置文件中。
     * 注意：此操作会改变配置文件的内存对象，通常后续需配合写入磁盘操作（当前代码仅执行了内存合并）。
     * @returns {void}
     */
    write(): void {
        const config = JSON.parse(fs.readFileSync(this.configFilePath, "utf8"));
        const param = JSON.parse(fs.readFileSync(this.paramFilePath, "utf8"));
        // 深度合并参数到配置对象
        _.merge(config, param);
        fs.writeFileSync(this.configFilePath, JSON.stringify(config));
    }

    /**
     * 恢复配置文件。
     * 从临时备份文件中还原配置文件，并覆盖当前已修改的文件。
     */
    recovery(): void {
        try {
            if (fs.existsSync(this.backupFileName)) {
                fs.copyFileSync(this.backupFileName, this.configFilePath);
                fs.unlinkSync(this.backupFileName);
            }
        } catch (e) {
            console.error(`恢复失败: ${e}`);
        }
    }
}
export default TaskParamHelper;
</file>

<file path="src/type/appenv.type.ts">
interface appEnv {
    isPkg: boolean;
    selfPath: string;
}

export type { appEnv };
</file>

<file path="src/type/env.d.ts">
declare namespace NodeJS {
    interface Process {
        pkg?: {
            entrypoint: string;
            defaultEntrypoint: string;
            mountpoint: string;
        };
    }
}
</file>

<file path="src/type/queue.type.ts">
import type { task } from "./task.type";

class queue {
    //类型, 应为queue
    type: string;
    //
    tasks: task[];

    constructor(q: queue) {
        if (q.type !== "queue") {
            //wait for test 25/12/6 16.50
            throw new Error("the queue type isnt queue");
        }

        this.type = q.type;
        this.tasks = q.tasks;
    }
}

export { queue };
</file>

<file path="src/type/task.type.ts">
interface taskParamConfig {
    //脚本参数文件路径
    paramFilePath: string;
    //配置文件路径
    configFilePath: string;
}

interface taskLogConfig {
    //日志文件搜索模式
    //"filename" 依据logFileName搜索日志文件 TODO
    //"latest" 查找最新(修改日期)的日志文件 TODO
    //"field" 依据logFileNameField字段搜索日志文件 TODO
    logFileSearchMethod: "filename" | "latest" | "field";
    //脚本日志文件夹路径
    logFileFolderPath: string;
    //脚本日志文件名称
    logFileName?: string;
    //脚本日志文件字段
    logFilenameField?: string;
    //日志时间戳开始位置
    logTimeSectionStart: number;
    //日志时间戳结束位置
    logTimeSectionEnd: number;
    //日志时间戳格式
    logTimeFormat: string;
    //成功日志
    successLog: string[] | string;
    //失败日志
    failedLog: string[] | string;
}

class task {
    //类型, 应为task
    type: string;
    //可执行文件路径
    executableFilePath: string;

    //是否需要参数
    isNeedParam: boolean;
    //参数设定
    taskParamConfig?: taskParamConfig;
    //是否需要根据日志判断运行情况,false则直接运行等到进程退出
    isNeedLog: boolean;
    //日志相关设定
    taskLogConfig?: taskLogConfig;

    //是否跟踪子进程 TODO
    trackChildProcess?: boolean;

    constructor(t: task) {
        if (t.type !== "task") {
            //wait for test 25/12/6 16.50
            throw new Error("the task type isnt task");
        }
        //parse file to self
        this.type = t.type;
        this.executableFilePath = t.executableFilePath;
        this.trackChildProcess = t.trackChildProcess;
        this.isNeedLog = t.isNeedLog;
        this.isNeedParam = t.isNeedParam;

        if (t.isNeedLog) {
            if (!t.taskLogConfig) {
                throw new Error("task need log, but didnt give log config");
            }
            this.taskLogConfig = t.taskLogConfig;
        }

        if (t.isNeedParam) {
            if (!t.taskParamConfig) {
                throw new Error("task need param, but didnt give param config");
            }
            this.taskParamConfig = t.taskParamConfig;
        }
    }
}

export { type taskParamConfig, type taskLogConfig, task };
</file>

<file path="tsconfig.json">
{
    "compilerOptions": {
        /* 1. 适配 pkg 的关键配置 */
        "target": "es2019", // pkg 对太新的语法支持有限，建议设为 ES2020 或更低
        "module": "CommonJS", // pkg 对 CJS 支持最稳，如果是 ESM 需要额外配置
        "outDir": "./dist", // 必须指定输出目录，方便 pkg 读取
        "rootDir": "./src", // 锁定源码根目录
        "lib": [
            "ES2019"
        ],
        "esModuleInterop": true, // 方便导入 CommonJS 编写的旧包
        "resolveJsonModule": true, // 允许导入 json，pkg 经常需要读取 package.json
        /* 3. 严格性与质量 */
        "strict": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true,
        "sourceMap": false, // 打包成二进制时，sourceMap 通常没用且增加体积
        "removeComments": true // 减小体积
    },
    "include": [
        "src/**/*"
    ],
    "exclude": [
        "node_modules",
        "dist",
        "bin"
    ]
}
</file>

</files>
